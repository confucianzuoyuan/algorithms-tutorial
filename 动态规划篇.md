动态规划(dynamic programming)与分治方法相似, 都是通过组合子问题的解来求解原问题(在这里, "programming"指的是一种表格法, 并非编写计算机程序). 如之前所述, 分治方法将问题划分为互不相交的子问题, 递归地求解子问题, 再将它们的解组合起来, 求出原问题的解. 与之相反, 动态规划应用于子问题重叠的情况, 即不同的子问题具有公共的子子问题(子问题的求解是递归进行的, 将其划分为更小的子子问题). 在这种情况下, 分治算法会做许多不必要的工作, 它会反复地求解那些公共子子问题. 而动态规划算法对每个子子问题只求解一次, 将其解保存在一个表格中, 从而无需每次求解一个子子问题时都重新计算, 避免了这种不必要的计算工作.

动态规划方法通常用来求解最优化问题(optimization problem). 这类问题可以有很多可行解, 每个解都有一个值, 我们希望寻找具有最优值(最小值或最大值)的解. 我们称这样的解为问题的一个最优解(an optimal solution), 而不是最优解 (the optimal solution), 因为可能有多个解都达到最优值.

我们通常按如下 4 个步骤来设计一个动态规划算法:
1. 刻画一个最优解的结构特征.
2. 递归地定义最优解的值.
3. 计算最优解的值, 通常采用自底向上的方法.
4. 利用计算出的信息构造一个最优解.

步骤 1~3 是动态规划算法求解问题的基础. 如果我们仅仅需要一个最优解的值, 而非解本身, 可以忽略步骤 4 . 如果确实要做步骤 4, 有时就需要在执行步骤 3 的过程中维护一些额外信息, 以便用来构造一个最优解.

下面我们将展示如何用动态规划方法来求解一些最优化问题. 本章第 1 节研究如何将长钢条切割成短钢条, 使得总价值最高. 第 2 节解决如何用最少的标量乘法操作完成一个矩阵链相乘的运算。 基于这些动态规划求解问题的例子, 第 3 节讨论适合用动态规划方法求解的问题应该具备的两个关键特征. 接下来, 第 4 节展示如何用动态规划方法找到两个序列的最长公共子序列. 最后, 第 5 节用动态规划方法解决在已知关键字分布的前提下, 如何构造最优二叉搜索树.

## 钢条切割

我们第一个应用动态规划的例子是求解一个如何切割钢条的简单问题. Serling 公司购买长钢条, 将其切割为短钢条出售. 切割工序本身没有成本支出. 公司管理层希望知道最佳的切割方案.

假定我们知道 Serling 公司出售一段长度为 $i$ 英寸的钢条的价格为 $p_i(i=1, 2, \cdots, 单位为美元)$ . 钢条的长度均为整英寸. 下图给出了一个价格表的样例.

| $长度i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|------|---|---|---|---|---|---|---|---|---|----|
|$价格\;p_i$ | 1 | 5 | 8 | 9 | 10 | 17 | 17 | 20 | 24 | 30 |

**图注解: 钢条价格表样例. 每段长度为 $i$ 英寸的钢条为公司带来 $p_i$ 美元的收益**

**钢条切割问题** 是这样的: 给定一段长度为 $n$ 英寸的钢条和一个价格表 $p_i(i=1, 2, \cdots, n)$, 求切割钢条方案, 使得销售收益 $r_n$ 最大. 注意, 如果长度为 $n$ 英寸的钢条的价格 $p_n$ 足够大, 最优解可能就是完全不需要切割.

![[钢条切割问题-1.svg]]

考虑 $n=4$ 的情况. 上图给出了 4 英寸钢条所有可能的切割方案, 包括根本不切割的方案. 我们发现, 将一段长度为 4 英寸的钢条切割为两段各长 2 英寸的钢条, 将产生 $p_2 + p_2 = 5 + 5 = 10$ 的收益, 为最优解.

长度为 $n$ 英寸的钢条共有 $2^{n-1}$ 种不同的切割方案, 因为在距离钢条左端 $i(i=1, 2, ..., n - 1)$ 英寸处, 我们总是可以选择切割或不切割. 我们用普通的加法符号表示切割方案, 因此 $7=2+2+3$ 表示将长度为 7 英寸的钢条切割为三段——两段长度为 2 英寸, 一段长度为 3 英寸. 如果一个最优解将钢条切割为 $k$ 段(对某个 $1\le k\le n$), 那么最优切割方案
$$
n = i_1 + i_2 + \cdots + i_k
$$
将钢条切割为长度分别为 $i_1, i_2 , ..., i_k$ 的小段, 得到最大收益
$$
r_n = p_{i_1} + p_{i_2} + \cdots + p_{i_k}
$$
对于上述价格表样例, 我们可以观察所有最优收益值 $r_i(i=1,2,\cdots,10)$ 及对应的最优切割方案:
- $r_1=1$, 切割方案 1=1(无切割)
- $r_2=5$, 切割方案 2=2(无切割)
- $r_3=8$, 切割方案 3=3(无切割)
- $r_4=10$, 切割方案 4=2+2
- $r_5=13$, 切割方案 5=2+3
- $r_6=17$, 切割方案 6=6(无切割)
- $r_7=18$, 切割方案 7=1+6 或 7=2+2+3
- $r_8=22$, 切割方案 8=2+6
- $r_9=25$, 切割方案 9=3+6
- $r_10=30$, 切割方案 10=10(无切割)
更一般地,对于 $r_n(n\ge 1)$, 我们可以用更短的钢条的最优切割收益来描述它:
$$
r_n = \max (p_n, r_1+r_{n-1}, r_2+r_{n-2}, \cdots, r_{n-1} + r_1)
$$
第一个参数 $p_n$ 对应不切割, 直接出售长度为 $n$ 英寸的钢条的方案. 其他 $n-1$ 个参数对应另外 $n-1$ 种方案: 对每个 $i=1, 2, ..., n-1$, 首先将钢条切割为长度为 $i$ 和 $n - i$ 的两段, 接着求解这两段的最优切割收益 $r_1$ 和 $r_{n-i}$ (每种方案的最优收益为两段的最优收益之和). 由于无法预知哪种方案会获得最优收益, 我们必须考察所有可能的 $i$, 选取其中收益最大者. 如果直接出售原钢条会获得最大收益, 我们当然可以选择不做任何切割.

注意到, 为了求解规模为 $n$ 的原问题, 我们先求解形式完全一样, 但规模更小的子问题. 即当完成首次切割后, 我们将两段钢条看成两个独立的钢条切割问题实例. 我们通过组合两个相关子问题的最优解, 并在所有可能的两段切割方案中选取组合收益最大者, 构成原问题的最优解. 我们称钢条切割问题满足最优子结构(optimal substructure)性质: 问题的最优解由相关子问题的最优解组合而成, 而这些子问题可以独立求解.

除了上述求解方法外, 钢条切割问题还存在一种相似的但更为简单的递归求解方法: 我们将钢条从左边切割下长度为 $i$ 的一段, 只对右边剩下的长度为 $n- i$ 的一段继续进行切割(递归求解), 对左边的一段则不再进行切割. 即问题分解的方式为: 将长度为 $n$ 的钢条分解为左边开始一段, 以及剩余部分继续分解的结果. 这样, 不做任何切割的方案就可以描述为: 第一段的长度为 $n$, 收益为 $p_n$, 剩余部分长度为 0, 对应的收益为 $r_0=0$ . 于是我们可以得到前面公式的简化版本:
$$
r_n=\max_{1\le i\le n}(p_i+r_{n-i})
$$
在此公式中, 原问题的最优解只包含一个相关子问题(右端剩余部分)的解, 而不是两个.

**自顶向下递归实现**

下面的过程实现了上面公式的计算, 它采用的是一种直接的自顶向下的递归方法.

```java
long CutRod(int[] p, int n) {
    if (n == 0) return 0;
    int q = Integer.MIN_VALUE;
    for (int i = 1; i < n + 1; i++) {
        q = Math.max(q, p[i] + CutRod(p, n - i));
    }
    return q;
}
```

程序 `CutRod` 以价格数组 `p[0..n]` 和整数 `n` 为输入, 返回长度为 `n` 的钢条的最大收益. 若 `n == 0`, 不可能有任何收益, 所以 `CutRod` 的第 2 行返回 0 . 第 3 行将最大收益 `q` 初始化为 `Integer.MIN_VALUE` , 以便第 4~5 行的 `for` 循环能正确计算 $q=\max_{1\le i\le n}(p_i+CutRod(p, n - i))$ , 第 6 行返回计算结果. 利用简单的归纳法, 可以证明此结果与公式计算出的最大收益 $r_n$ 是相等的.

如果我们运行程序, 会发现, 一旦输入规模稍微变大, 程序运行时间会变得相当长. 例如, 对 $n=40$, 程序至少运行好几分钟, 很可能超过一小时. 实际上, 你会发现, 每当将 $n$ 增大 1, 程序运行时间差不多就会增加 1 倍.

为什么 `CutRod` 的效率这么差? 原因在于, `CutRod` 反复地用相同的参数值对自身进行递归调用, 即它反复求解相同的子问题. 下图显示了 $n=4$ 时的调用过程: `CutRod(p, n)` 对 $i=1,2, ..., n$ 调用 `CutRod(p, n — i)` , 等价于对 $j=0,1,...,n-1$ 调用 `CutRod(p,j)` . 当这个过程递归展开时, 它所做的工作量(用 $n$ 的函数的形式描述)会爆炸性地增长.

![[钢条切割问题-2.svg|600]]

为了分析 `CutRod` 的运行时间, 令 $T(n)$ 表示第二个参数值为 $n$ 时 `CutRod` 的调用次数. 此值等于递归调用树中根为 $n$ 的子树中的结点总数, 注意, 此值包含了根结点对应的最初的一次调用. 因此 $T(0)=1$, 且
$$
T(n)=1+\sum_{j=0}^{n-1}T(j)
$$
第一项 `1` 表示函数的第一次调用(递归调用树的根结点), $T(j)$ 为调用 `CutRod(p, n-i)` 所产生的所有调用(包括递归调用)的次数, 此处 $j=n-i$ . 我们可以证明:
$$
T(n)=2^n
$$
即 `CutRod` 的运行时间为 $n$ 的指数函数.

回过头看, `CutRod` 的指数运行时间并不令人惊讶. 对于长度为 $n$ 的钢条, `CutRod` 显然考察了所有 $2^{n-1}$ 种可能的切割方案. 递归调用树中共有 $2^{n-1}$ 个叶结点, 每个叶结点对应一种可能的钢条切割方案. 对每条从根到叶的路径, 路径上的标号给出了每次切割前右边剩余部分的长度(子问题的规模). 也就是说, 标号给出了对应的切割点(从钢条右端测量).

**使用动态规划方法求解最优钢条切割问题**

我们现在展示如何将 `CutRod` 转换为一个更高效的动态规划算法.

动态规划方法的思想如下所述. 我们已经看到, 朴素递归算法之所以效率很低,是因为它反复求解相同的子问题. 因此, 动态规划方法仔细安排求解顺序, 对每个子问题只求解一次, 并将结果保存下来. 如果随后再次需要此子问题的解, 只需要查找保存的结果, 而不必重新计算. 因此, 动态规划方法是付出额外的内存空间来节省计算时间, 是典型的时空权衡(time-memory trade-off)的例子. 而时间上的节省可能是非常巨大的: 可能将一个指数时间的解转化为一个多项式时间的解. 如果子问题的数量是输入规模的多项式函数, 而我们可以在多项式时间内求解出每个子问题, 那么动态规划方法的总运行时间就是多项式阶的.

动态规划有两种等价的实现方法, 下面以钢条切割问题为例展示这两种方法.

第一种方法称为带备忘的自顶向下法 (top-down with memoization). 此方法仍按自然的递归形式编写过程, 但过程会保存每个子问题的解(通常保存在一个数组或散列表中). 当需要一个子问题的解时, 过程首先检查是否已经保存过此解. 如果是, 则直接返回保存的值, 从而节省了计算时间; 否则, 按通常方式计算这个子问题. 我们称这个递归过程是带备忘的(memoized), 因为它"记住"了之前已经计算出的结果.

第二种方法称为自底向上法(bottom-up method). 这种方法一般需要恰当定义子问题"规模"的概念, 使得任何子问题的求解都只依赖于"更小的"子问题的求解. 因而我们可以将子问题按规模排序, 按由小至大的顺序进行求解. 当求解某个子问题时, 它所依赖的那些更小的子问题都已求解完毕, 结果已经保存. 每个子问题只需求解一次, 当我们求解它(也是第一次遇到它)时, 它的所有前提子问题都已求解完成.

两种方法得到的算法具有相同的渐近运行时间, 仅有的差异是在某些特殊情况下, 自顶向下方法并未真正递归地考察所有可能的子问题. 由于没有频繁的递归函数调用的开销, 自底向上方法的时间复杂性函数通常具有更小的系数.

下面给出的是自顶向下 `CutRod` 过程的代码, 加入了备忘机制:

```java
long MemoizedCutRod(int[] p, int n) {
    var r = new int[n + 1];
    for (int i = 0; i < n + 1; i++) {
        r[i] = Integer.MIN_VALUE;
    }
    return MemoizedCutRodAux(p, n, r);
}

long MemoizedCutRodAux(int[] p, int n, int[] r) {
    if (r[n] >= 0) return r[n];
    int q;
    if (n == 0) q = 0;
    else {
        q = Integer.MIN_VALUE;
        for (int i = 1; i < n + 1; i++) {
            q = Math.max(q, p[i] + MemoizedCutRodAux(p, n-i, r));
        }
    }
    r[n] = q;
    return q;
}
```

这里, 主过程 `MEMOIZED-CUT-ROD` 将辅助数组 `r[0..n]` 的元素均初始化为 `Integer.MIN_VALUE` , 这是一种常见的表示"未知值"的方法(已知的收益总是非负值). 然后它会调用辅助过程 `MEMOIZEDCUT-ROD-AUX` .

过程 `MEMOIZED-CUT-ROD-AUX` 是最初的 `CUT-ROD` 引入备忘机制的版本. 它首先检查所需值是否已知(第 1 行), 如果是, 则第 2 行直接返回保存的值; 否则, 第 3~7 行用通常方法计算所需值 `q`, 第 8 行将 `q` 存入 `r[n]`, 第 9 行将其返回.

自底向上版本更为简单:

```java
long BottomUpCutRod(int[] p, int n) {
    var r = new int[n + 1];
    r[0] = 0;
    for (int j = 1; j <= n; j++) {
        int q = Integer.MIN_VALUE;
        for (int i = 1; i <= j; i++) {
            q = Math.max(q, p[i]+r[j-i]);
        }
        r[j] = q;
    }
    return r[n];
}
```

自底向上版本 `BOTTOM-UP-CUT-ROD` 采用子问题的自然顺序: 若 `i<j`, 则规模为 `i` 的子问题比规模为 `j` 的子问题"更小". 因此, 过程依次求解规模为`j=O, 1,...,n` 的子问题.

过程 `BOTTOM-UP-CUT-ROD` 的第 1 行创建一个新数组 `r[0..n]` 来保存子问题的解, 第 2 行将 `r[0]` 初始化为 0, 因为长度为 0 的钢条没有收益. 第 3~6 行对 `j=1, 2, ..., n` 按升序求解每个规模为 `j` 的子问题. 求解规模为 `j` 的子问题的方法与 `CUT-ROD` 所采用的方法相同, 只是现在直接访问数组元素 `r[j-i]` 来获得规模为 `j-i` 的子问题的解(第 6 行), 而不必进行递归调用. 第 7 行将规模为 `j` 的子问题的解存入 `r[j]` . 最后, 第 8 行返回 `r[n]`, 即最优解 $r_n$.

自底向上算法和自顶向下算法具有相同的渐近运行时间. 过程 `BOTTOM-UP-CUT-ROD` 的主体是嵌套的双重循环, 内层 `for` 循环(第 5~6 行)的迭代次数构成一个等差数列, 不难分析过程的运行时间为 $O(n^2)$ .自顶向下的 `MEMOIZED-CUT-ROD` 的运行时间也是 $O(n^2)$, 其分析略难一些: 当求解一个之前已计算出结果的子问题时, 递归调用会立即返回, 即 `MEMOIZED­-CUT-ROD` 对每个子问题只求解一次, 而它求解了规模为 `0, 1, ..., n` 的子问题; 为求解规模为 `n` 的子问题, 第 6~7 行的循环会迭代 `n` 次; 因此,  `MEMOIZED-CUT-ROD` 进行的所有递归调用执行此 `for` 循环的迭代次数也是一个等差数列, 其和也是 $O(n^2)$, 与 `BOTTOM-UP-CUT-ROD` 内层 `for` 循环的迭代总次数一样.

**子问题图**

**重构解**

## 动态规划原理

虽然我们已经用动态规划方法解决了两个问题, 但你可能还是弄不清应该在何时使用动态规划. 从工程角度看, 在什么情况下应该寻求用动态规划方法求解问题呢? 在本节中, 我们关注适合应用动态规划方法求解的最优化问题应该具备的两个要素: 最优子结构和子问题重叠. 我们还会再次讨论备忘方法, 更深入地讨论在自顶向下方法中如何借助备忘机制来充分利用子问题重叠特性.

**最优子结构**

用动态规划方法求解最优化问题的第一步就是刻画最优解的结构. 如前文所述, 如果一个问题的最优解包含其子问题的最优解, 我们就称此问题具有最优子结构性质. 因此, 某个问题是否适合应用动态规划算法, 它是否具有最优子结构性质是一个好线索(当然, 具有最优子结构性质也可能意味着适合应用贪心策略). 使用动态规划方法时, 我们用子问题的最优解来构造原问题的最优解. 因此, 我们必须小心确保考察了最优解中用到的所有子问题.

**重叠子问题**

适合用动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够"小", 即问题的递归算法会反复地求解相同的子问题, 而不是一直生成新的子问题. 一般来讲, 不同子问题的总数是输入规模的多项式函数为好. 如果递归算法反复求解相同的子问题, 我们就称最优化问题具有重叠子问题(overlapping subproblems)性质. 与之相对的, 适合用分治方法求解的问题通常在递归的每一步都生成全新的子问题. 动态规划算法通常这样利用重叠子问题性质: 对每个子问题求解一次, 将解存入一个表中, 当再次需要这个子问题时直接查表, 每次查表的代价为常量时间.

**重构最优解**

**备忘**

