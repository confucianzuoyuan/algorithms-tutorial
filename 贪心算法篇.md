求解最优化问题的算法通常需要经过一系列的步骤, 在每个步骤都面临多种选择. 对于许多最优化问题, 使用动态规划算法来求最优解有些杀鸡用牛刀了, 可以使用更简单, 更高效的算法. 贪心算法(greedy algorithm)就是这样的算法, 它在每一步都做出当时看起来最佳的选择. 也就是说, 它总是做出局部最优的选择, 寄希望这样的选择能导致全局最优解. 本章介绍一些贪心算法能找到最优解的最优化问题.

贪心算法并不保证得到最优解, 但对很多问题确实可以求得最优解. 我们首先在第 1 节介绍一个简单但非平凡的问题——活动选择问题, 这是一个可以用贪心算法求得最优解的问题. 首先考虑用动态规划方法解决这个问题, 然后证明一直做出贪心选择就可以得到最优解, 从而得到一个贪心算法. 第 2 节会回顾贪心方法的基本要素, 并给出一个直接的方法, 可用来证明贪心算法的正确性. 第 3 节提出贪心技术的一个重要应用: 设计数据压缩编码(Huffman编码).

贪心方法是一种强有力的算法设计方法, 可以很好地解决很多问题.

## 贪心算法原理

贪心算法通过做出一系列选择来求出问题的最优解. 在每个决策点, 它做出在当时看来最佳的选择. 这种启发式策略并不保证总能找到最优解, 但对有些问题确实有效, 如活动选择问题. 本节讨论贪心方法的一些一般性质.

第 1 节中设计贪心算法的过程比通常的过程繁琐一些, 我们当时经过了如下几个步骤:

1. 确定问题的最优子结构.
2. 设计一个递归算法(对活动选择问题, 我们给出了递归式, 但跳过了基于此递归式设计递归算法的步骤).
3. 证明如果我们做出一个贪心选择, 则只剩下一个子问题.
4. 证明贪心选择总是安全的(步骤 3 , 4 的顺序可以调换).
5. 设计一个递归算法实现贪心策略.
6. 将递归算法转换为迭代算法.

在这个过程中, 我们详细地看到了贪心算法是如何以动态规划方法为基础的. 例如, 在活动选择问题中, 我们首先定义了子问题 $S_{ij}$ 其中 $i$ 和 $j$ 都是可变的. 然后我们发现, 如果总是做出贪心选择, 则可以将子问题限定为 $S_k$ 的形式.

与这种繁琐的过程相反, 我们可以通过贪心选择来改进最优子结构, 使得选择后只留下一个子问题. 在活动选择问题中, 我们可以一开始就将第二个下标去掉, 将子问题定义为 $S_k$ 的形式. 然后, 我们可以证明, 贪心选择($S_k$中最早结束的活动$a_m$)与剩余兼容活动集的最优解组合在一起, 就会得到 $S_k$ 的最优解. 更一般地, 我们可以按如下步骤设计贪心算法:

1. 将最优化问题转化为这样的形式: 对其做出一次选择后, 只剩下一个子问题需要求解.
2. 证明做出贪心选择后, 原问题总是存在最优解, 即贪心选择总是安全的.
3. 证明做出贪心选择后, 剩余的子问题满足性质: 其最优解与贪心选择组合即可得到原问题的最优解, 这样就得到了最优子结构.

在本章剩余部分中, 我们将使用这种更直接的设计方法. 但我们应该知道, 在每个贪心算法之下, 几乎总有一个更繁琐的动态规划算法.

我们如何证明一个贪心算法是否能求解一个最优化问题呢? 并没有适合所有情况的方法, 但贪心选择性质和最优子结构是两个关键要素. 如果我们能够证明问题具有这些性质, 就向贪心算法迈出了重要一步.

**贪心选择性质**

第一个关键要素是贪心选择性质(greedy-choice property): 我们可以通过做出局部最优(贪心)选择来构造全局最优解. 换句话说, 当进行选择时, 我们直接做出在当前问题中看来最优的选择, 而不必考虑子问题的解.

这也是贪心算法与动态规划的不同之处. 在动态规划方法中, 每个步骤都要进行一次选择, 但选择通常依赖于子问题的解. 因此, 我们通常以一种自底向上的方式求解动态规划问题, 先求解较小的子问题, 然后是较大的子问题(我们也可以自顶向下求解, 但需要备忘机制. 当然, 即使算法是自顶向下进行计算, 我们仍然需要先求解子问题再进行选择). 在贪心算法中, 我们总是做出当时看来最佳的选择, 然后求解剩下的唯一的子问题. 贪心算法进行选择时可能依赖之前做出的选择, 但不依赖任何将来的选择或是子问题的解. 因此, 与动态规划先求解子问题才能进行第一次选择不同, 贪心算法在进行第一次选择之前不求解任何子问题. 一个动态规划算法是自底向上进行计算的, 而一个贪心算法通常是自顶向下的, 进行一次又一次选择, 将给定问题实例变得更小.

当然,我们必须证明每个步骤做出贪心选择能生成全局最优解. 如定理 16. 1 所示, 这种证明通常首先考查某个子问题的最优解, 然后用贪心选择替换某个其他选择来修改此解, 从而得到一个相似但更小的子问题.

如果进行贪心选择时我们不得不考虑众多选择, 通常意味着可以改进贪心选择, 使其更为高效. 例如, 在活动选择问题中, 假定我们已经将活动按结束时间单调递增顺序排好序, 则对每个活动能够只需处理一次. 通过对输入进行预处理或者使用适合的数据结构(通常是优先队列), 我们通常可以使贪心选择更快速, 从而得到更高效的算法.

## 哈夫曼编码

哈夫曼编码可以很有效地压缩数据: 通常可以节省 20%~90% 的空间, 具体压缩率依赖于数据的特性. 我们将待压缩数据看做字符序列. 根据每个字符的出现频率, 哈夫曼贪心算法构造出字符的最优二进制表示.

假定我们希望压缩一个 10 万个字符的数据文件. 下图给出了文件中所出现的字符和它们的出现频率. 也就是说, 文件中只出现了 6 个不同字符, 其中字符 a 出现了 45 000 次.

