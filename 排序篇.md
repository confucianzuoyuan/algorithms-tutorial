## 力扣第912题: 排序数组

给你一个整数数组 `nums`, 请你将该数组升序排列.

示例 1:

```
输入: nums = [5,2,3,1]
输出: [1,2,3,5]
```

示例 2:

```
输入: nums = [5,1,1,2,0,0]
输出: [0,0,1,1,2,5]
```

提示:

- <code>1 <= nums.length <= 5 * 10<sup>4</sup></code>
- <code>-5 * 10<sup>4</sup> <= nums[i] <= 5 * 10<sup>4</sup></code>

### 解法

**插入排序**

我们首先介绍插入排序, 对于少量元素的排序, 它是一个有效的算法. 插入排序的工作方式像许多人排序一手扑克牌. 开始时, 我们的左手为空并且桌子上的牌面向下. 然后. 我们每次从桌子上拿走一张牌并将它插入左手中正确的位置. 为了找到一张牌的正确位置, 我们从右到左将它与已在手中的每张牌进行比较. 拿在左手上的牌总是排序好的, 原来这些牌是桌子上牌堆中顶部的牌. 如下图所示:

![](figures/算法基础/插入排序的纸牌示意图/figure.svg)
插入排序程序接收一个参数: 一个参数是数组`nums`, 包含了将被排序的数组元素. 数组元素占据 `nums[0]` 到 `nums[n − 1]` 的位置, 我们表示为 `nums[0..n − 1]`. 当插入排序程序执行完毕时, 数组 `A[0..n − 1]` 包含了已经排过序的原始数组中的所有元素.

代码如下:

```java
 1  class Solution {
 2      public int[] sortArray(int[] nums) {
 3          int N = nums.length;
 4          for (int i = 1; i < N; i++) {
 5              int key = nums[i];
 6              // 将nums[i]插入到已经排序好的子数组nums[0:i-1]
 7              int j = i - 1;
 8              while (j >= 0 && nums[j] > key) {
 9                  nums[j+1] = nums[j];
10                  j--;
11              }
12              nums[j+1] = key;
13          }
14          return nums;
15      }
16  }
```

**循环不变量与插入排序的正确性**

![[figures/算法基础/插入排序完整过程示意图/figure.svg|600]]

上图表明对 `nums = [5, 2, 4, 6, 1, 3]` 数组插入排序算法如何工作. 下标 `i` 指出正被插入到手中的"当前牌". 在 `for` 循环 (循环变量为 `i`) 的每次迭代的开始, 包含元素 `nums[0..i-1]` 的子数组构成了当前排序好的左手中的牌, 剩余的子数组`nums[i + 1..n − 1]` 对应于仍在桌子上的牌堆. 事实上, 元素 `nums[0..i-1]` 就是原来在位置 `0` 到 `i-1` 的元素, 但现在已按序排列. 我们把 `nums[0..i − 1]` 的这些性质形式地表示为一个循环不变量:

> 在每次 `for` 迭代 (3-13 行) 开始时, 子数组 `nums[0..i−1]` 包括了最开始在`nums[0..i−1]`中的数组元素, 但是已经经过了排序.

循环不变量主要用来帮助我们理解算法的正确性. 关于循环不变量. 我们必须证明三条性质:

**初始化**: 首先证明在第一次循环迭代之前(当 `i = 1` 时), 循环不变量成立. 所以子数组 `nums[0..i − 1]` 仅由单个元素 `nums[0]` 组成, 实际上就是 `nums[0]` 中原来的元素. 而且该子数组是排序好的(当然很平凡). 这表明第一次循环迭代之前循环不变量成立.

**保持**: 其次处理第二条性质, 证明每次迭代保持循环不变量. 非形式化地, `for` 循环体的第 6-10 行将 `nums[i − 1], nums[i—2], nums[i − 3]` 等向右移动一个位置, 直到找到 `nums[i]` 的适当位置, 第 11 行将 `nums[i]` 的值插入该位置. 这时子数组 `nums[0..i]` 由原来在 `nums[0..i]` 中的元素组成, 但已按序排列. 那么对 `for` 循环的下一次迭代增加 `i` 将保持循环不变量. 第二条性质的一种更形式化的处理要求我们对第 7-10 行的 `while` 循环给出并证明一个循环不变量. 然而, 这里我们不愿陷入形式主义的困境, 而是依赖以上非形式化的分析来证明第二条性质对外层循环成立.

**终止**: 最后研究在循环终止时发生了什么. 导致 `for` 循环终止的条件是 `i > n − 1`. 因为每次循环迭代 `i` 增加 `1`, 那么循环终止时, 必有 `i = n`. 在循环不变量的表述中将 `i` 用 `n` 代替, 我们有: 子数组 `nums[0..n − 1]` 由原来在 `nums[0..n − 1]` 中的元素组成, 但已按序排列. 注意到, 子数组 `nums[0..n − 1]` 就是整个数组, 我们推断出整个数组已排序. 因此算法正确.

接下来我们分析一下时间复杂度.
- 第3行: 时间复杂度是$O(1)$.
- 第4行: 每次执行的代价是$O(1)$, 一共执行了$N$次. 时间复杂度是$O(n)$.
- 第5行: 每次执行的代价是$O(1)$, 一共执行了$N-1$次, 时间复杂度是$O(n-1)=O(n)$.
- 第7行: 每次执行的代价是$O(1)$, 一共执行了$n-1$次, 时间复杂度是$O(n-1)=O(n)$.
- 第8行: 假设 `while` 循环的执行次数是$t_i$次, 那么一共执行了 $\sum_{i=1}^{n-1}t_i$ . 时间复杂度是$O(\sum_{i=1}^{n-1}t_i)$.
- 第9行: `while`循环体内的代码的循环次数比`while`循环的条件判断少一次, 所以时间复杂度是 $O(\sum_{i=1}^{n-1}(t_i-1))$ .
- 第10行: 时间复杂度是 $O(\sum_{i=1}^{n-1}(t_i-1))$ .
- 第12行: 每次执行的代价是$O(1)$, 一共执行了$n-1$次, 时间复杂度是$O(n-1)=O(n)$.
- 第14行: 时间复杂度是$O(1)$.

把以上都加起来得到如下
$$
T(n) = 4O(n) + 2O(1) + O(\sum_{i=1}^{n-1}t_i) + 2O(\sum_{i=1}^{n-1}(t_i-1))
$$
当数组最开始时已经是升序排列, 那么有$t_i=1$, 那么上面的式子最后计算出来是$T(n)=4O(n)+2O(1)+O(n-1)=O(n)$. 所以可以看到在最好的情况下, 插入排序的时间复杂度是线性的.

若输入数组已反向排序, 即按递减序排好序, 则导致最坏运行情况. 我们必须将每个元素 `nums[i]` 与整个已排序子数组 `nums[0..i - 1]` 中的每个元素进行比较, 所以对 `i = 1, 2, ... , n - 1`, 有 `t_i = i + 1`.(这个过程会发现每次执行第 5 行时, 有`nums[j] > key`, 以及只有当 `j` 到达 `0` 时, `while` 才会退出.) 注意到
$$
T(n) = 4O(n) + 2O(1) + O(\sum_{i=1}^{n-1}(i+1)) + 2O(\sum_{i=1}^{n-1}i)
$$
由于
$$
\begin{aligned}
\sum_{i=1}^{n-1}(i+1) &= 2 + 3 + \cdots + n \\
                      &= \sum_{i=2}^ni \\
                      &= \frac{n(n+1)}{2} - 1
\end{aligned}
$$
以及
$$
\sum_{i=1}^{n-1}i = \frac{n(n-1)}{2}
$$

所以省略掉低阶项和系数, 最坏情况下时间复杂度是$O(n^2)$.

**快速排序**



## 力扣第215题: 数组中的第K个最大元素

给定整数数组 `nums` 和整数 `k`, 请返回数组中第 `k` 个最大的元素.

请注意, 你需要找的是数组排序后的第 `k` 个最大的元素, 而不是第 `k` 个不同的元素.

你必须设计并实现时间复杂度为 $O(n)$ 的算法解决此问题.

示例 1:

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

示例 2:

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

提示:

- <code>1 <= k <= nums.length <= 10<sup>5</sup></code>
- <code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code>

### 解法

**快速选择算法**

## 力扣第347题: 前 K 个高频元素

给你一个整数数组 `nums` 和一个整数 `k` , 请你返回其中出现频率前 `k` 高的元素. 你可以按 **任意顺序** 返回答案.

示例 1:

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

示例 2:

```
输入: nums = [1], k = 1
输出: [1]
```

提示:
-   <code>1 <= nums.length <= 10<sup>5</sup></code>
-   `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
-   题目数据保证答案唯一, 换句话说, 数组中前 `k` 个高频元素的集合是唯一的

进阶: 你所设计算法的时间复杂度**必须**优于 $O(n \log n)$, 其中 `n` 是数组大小.

## 力扣第295题: 数据流的中位数

**中位数**是有序整数列表中的中间值. 如果列表的大小是偶数, 则没有中间值, 中位数是两个中间值的平均值.
- 例如 `arr = [2,3,4]` 的中位数是 `3` .
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` .

实现 `MedianFinder` 类:
-  `MedianFinder()` 初始化 `MedianFinder` 对象.
-  `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中.
-  `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受.

示例 1:

```
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

提示:
-  $-10^5 \le num \le 10^5$
-  在调用 `findMedian` 之前，数据结构中至少有一个元素
-  最多 $5 * 10^4$ 次调用 `addNum` 和 `findMedian`

## 力扣第21题: 合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回. 新链表是通过拼接给定的两个链表的所有节点组成的.

示例 1:

![[21-1.jpg]]

```
输入: l1 = [1,2,4], l2 = [1,3,4]
输出: [1,1,2,3,4,4]
```

示例 2:

```
输入: l1 = [], l2 = []
输出: []
```

示例 3:

```
输入: l1 = [], l2 = [0]
输出: [0]
```

提示:
- 两个链表的节点数目范围是 `[0, 50]`.
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

## 力扣第148题: 排序链表

给你链表的头结点 `head` , 请将其按 **升序** 排列并返回 **排序后的链表** .

示例 1:

![[148-1.jpg]]

```
输入: head = [4,2,1,3]
输出: [1,2,3,4]
```

示例 2:

![[148-2.jpg]]

```
输入: head = [-1,5,3,4,0]
输出: [-1,0,3,4,5]
```

示例 3:

```
输入: head = []
输出: []
```

提示:
- 链表中节点的数目在范围 $[0, 5 * 10^4]$ 内
- $-10^5 \le Node.val \le 10^5$

进阶：你可以在 $O(n \log n)$ 时间复杂度和常数级空间复杂度下, 对链表进行排序吗?

## 力扣第23题: 合并 K 个升序链表

给你一个链表数组, 每个链表都已经按升序排列.

请你将所有链表合并到一个升序链表中, 返回合并后的链表.

示例 1:

```
输入: lists = [[1,4,5],[1,3,4],[2,6]]
输出: [1,1,2,3,4,4,5,6]
解释: 链表数组如下:
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到:
1->1->2->3->4->4->5->6
```

示例 2:

```
输入: lists = []
输出: []
```

示例 3：

```
输入: lists = [[]]
输出: []
```

提示:
- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 升序 排列
- `lists[i].length` 的总和不超过 `10^4`.