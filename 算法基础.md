## 算法基础

### 算法是什么?

非形式化地说, 算法(algorithm)就是任何经过良好定义的计算过程, 这个过程取某个值或值的集合作为输入并在有限的时间内产生某个值或值的集合作为输出. 这样算法就是把输入转换成输出的计算步骤的一个序列.

**快速排序作为算法的一个例子**

![](快速排序作为算法的例子.svg)

**编译器作为算法的一个例子**

![](编译器作为算法的例子.svg)

**GPT模型作为算法的一个例子**

![](GPT模型作为算法的例子.svg)

### 算法需要满足的条件

- 在合理的时间内运行结束. 一个排序执行1年不太合适.
- 不能占用太大的空间, 一个排序占用1T内存不太合适.

### 为什么要学习算法?

- 计算机科学所有分支学科的核心都是算法
- 顶尖工程师一定精通算法
- 学好算法是成为一名优秀的工程师的必要条件

### 一些应用场景举例

- 操作系统内核:
  - 各种链表的使用
  - 红黑树(epoll)
  - 环形缓冲区
  - ...
- 编译器
  - 有限状态机
  - 树(抽象语法树)
  - 图论(寄存器分配)
  - 垃圾收集(深度优先搜索)
  - ...
- 数据库
  - B+树(MySQL索引)
  - 图论(执行计划的优化)
  - 树形结构(抽象语法树)
  - ...
- TCP-IP协议
  - 有限状态机(三次握手的流程)
  - 滑窗算法(流量控制和乱序重排)
  - ...
- 分布式系统
  - Paxos算法(zookeeper, etcd, ...)
  - 工作量证明(比特币)
  - ...
- GPT模型
  - 反向传播算法(动态规划+链式求导)
  - 多层感知机
  - Transformer模型
  - ...

### 程序的性能分析

- 时间复杂度: 主要分析一个程序需要执行多长时间
- 空间复杂度: 主要分析一个程序需要使用多少内存

> 程序执行多长时间说的更加精确一些应该是: 需要多少个**时间单位**
>
> 程序的空间复杂度, 我们一般分析内存的占用情况, 磁盘之类的外存一般不考虑

### 为什么要分析程序的性能?

- CPU可能很快, 但不是无限快
- 内存和磁盘可能很便宜, 但并不是无限大和不要钱的
- 解决同样的问题, 一个好的算法比一个不好的算法需要的时间少得多

> 例如: 一个已经排序好的包含1亿个元素的数组, 要查找1个元素是否在数组中, 使用线性查找算法(也就是从头到尾遍历数组去查找这个元素), 如果碰到最坏的情况(待查找元素不在数组中), 那么需要花费1亿个时间单位才能发现元素不在数组中. 如果使用二分查找算法, 那么碰到最坏的情况, 只需要$\log_2(1,0000,0000)\approx 27$次就可以得出元素不在数组中的结论.

### 程序性能是基于什么样的计算机模型来说的?

- 肯定不能是量子计算机模型.
- 我们使用简单的通行的冯诺依曼-图灵架构.

### 我们选用的冯诺依曼架构的特点

- 单核(只有1个CPU)
- CPU的指令一条接着一条的按顺序执行(不存在并行执行)
- CPU的指令集只包含简单的指令
  - 算术指令: 加法, 减法, 乘法, 除法, 取余, 向下取整, 向上取整
  - 数据移动指令: 加载, 存储, 复制
  - 控制指令: 条件与无条件转移, 子程序调用与返回
  - 每条这样的指令所需时间都为常量(一个时间单位)
  - 没有排序指令, 矩阵相乘指令这样的神奇指令
- 内存是随机存取器(Random Access Memory, RAM)
- 内存是一个巨大的字节数组
- 使用索引读写内存中的某个字节例如: `a[1] = 1;`, 花费常量时间(1个时间单位)

假设我们的CPU是8位的, 那么寻址空间(也就是索引字节数组的大小)是$0\sim 255$. 换成十六进制表示则是$0x00 \sim 0xFF$. 如下图所示:

![](内存模型示意图.svg)

### 时间复杂度

我们一般假设一段程序的时间复杂度(运行时间)是$T(N)$, $N$表示程序的输入规模(例如数组的大小, 大整数的位数等等). 那么$T(N)$一般求得的结果我们使用**大$O$表示法**来表示. 我们通过举例子的方式来看一下大$O$表示法是什么东西.

> 大$O$表示法是最常用的, 时间复杂度的分析其实涉及很深的数学知识, 有大$O$表示法, 大$\Theta$表示法, 大$\Omega$表示法等等. 但这里为了方便理解, 我们只讲大$O$表示法, 并将它通俗化.

**常数时间**$O(1)$

> 表示只使用1个时间单位.

```java
int f() {
    return 1;
}
```

假设方法`f`的时间复杂度是$T$, 由于`return 1`返回语句只需要1个时间单位, 所以`f`的时间复杂度是$T=O(1)$.

```java
int f() {
    int a = 1;
    return a;
}
```

两条语句的时间复杂度都是$O(1)$, 而$O(1) + O(1) = 2O(1) = O(1)$. 这个等式可能有些奇怪, 但没有问题. 因为大$O$表示法本身是时间复杂度的一个大概估计(精确分析非常困难且没有必要). 所以我们一般舍弃低阶项和常数系数. 例如: $O(2N) = O(N)$, $O(N)+O(N^2)=O(N^2)$等等.

**线性时间**$O(N)$

> 表示使用$N$个时间单位

```java
int f(int N) {
    int sum = 0;
    int i = 0;
    while (i < N) {
        sum += i;
        i++;
    }
    return sum;
}
```

假设方法`f`的时间复杂度是$T(N)$, 我们逐行分析:

- 第2行: `int sum = 0;`的时间复杂度是$O(1)$.
- 第3行: `int i = 0;`的时间复杂度是$O(1)$.
- 第4行: 每次`while`循环都要检测一次循环条件`i < N`, 检测的时间复杂度是$O(1)$. 一共检测了$N$次. 所以总的时间复杂度是$O(N)$.
- 第5行: `sum += i`等价于`sum = sum + i;`, 那么时间复杂度是$O(2) = O(1)$(一个加法操作, 一个赋值操作). 共执行了$N$次, 所以时间复杂度是$O(N)$.
- 第6行: `i++`的时间复杂度是$O(1)$, 共执行了$N$次. 那么时间复杂度是$O(N)$.
- 第8行: `return sum`的时间复杂度是$O(1)$.

把每一行代码所用的时间加起来得到
$$
\begin{equation*}
\begin{aligned}
T(N) &= O(1) + O(1) + O(N) + O(N) + O(1) \\
     &= 3O(1) + 2O(N) \\
     &= O(N)
\end{aligned}
\end{equation*}
$$
所以方法`f`的时间复杂度是$O(N)$, 也就是线性时间复杂度.

**平方时间**$O(N^2)$

```java
void InsertionSort(int[] A) {
    for (int i = 1; i < A.length; i++) {
        int key = A[i];
        // 将A[i]插入到已经排好序的子数组A[0:i-1]
        int j = i - 1;
        while (j >= 0 && A[j] > key) {
            A[j + 1] = A[j];
            j = j - 1;
        }
        A[j + 1] = key;
    }
}
```

上面的代码是插入排序的代码. 我们不关心算法的细节. 我们关注的是这段代码的时间复杂度如何计算?

或者说在最坏情况下, 这段代码的时间复杂度是多少? 我们来逐行分析

- 第2行: 需要时间为$O(1)$, 执行次数是$N$次. 时间复杂度: $O(N)$.
- 第3行: 需要时间为$O(1)$, 执行次数是$N-1$次. 时间复杂度: $O(N-1)=O(N)$.
- 第4行: 需要时间为$O(1)$, 执行次数是$N-1$次. 时间复杂度: $O(N-1)=O(N)$.
- 第5行: 需要时间为$O(1)$, 把以下都加起来$\sum_{j=2}^Nj=2 + 3 + \cdots + N=O(N^2)$.
  - 当$i=1$时, 执行次数是2次.
  - 当$i=2$时, 执行次数是3次.
  - ...
  - 当$i=N-1$时, 执行次数是$N$次.
- 第7行: $O(N^2)$.
- 第8行: $O(N^2)$.
- 第10行: $O(N-1)=O(N)$.

所以$T(N)=4O(N) + 3O(N^2)=O(N^2)$.

**对数时间**$O(\log{N})$

这里的符号$\log{N}$实际上是$\log_2N$. 因为在计算机中, 不明确说明对数都是**以2为底**的.

通常情况下, 当我们将一个问题分割为完全不重合的子问题时, 时间复杂度就会出现对数时间.

我们举个二分查找的例子.

```java
int RecursiveBinarySearch(int[] array, int target, int left, int right) {
    if (left <= right) {
        int mid = (left + right) / 2;
        if (array[mid] == target) {
            return mid;
        } else if (array[mid] < target) {
            return RecursiveBinarySearch(array, target, mid + 1, right);
        } else {
            return RecursiveBinarySearch(array, target, left, mid - 1);
        }
    }
    
    return -1;
}
```

上面是递归实现的二分查找算法. 我们来考虑最坏情况下的时间复杂度, 而最坏情况就是要查找的元素`target`不在数组`array`里面.

我们假设上面方法的时间复杂度是$T(N)$. $N$是`array`数组的长度. 由于方法体中的递归调用针对的是砍掉一半的数组, 所以第7行和第9行的时间复杂度分别是$T(N/2)$. 而第7行和第9行的递归调用每次只会调用其中一个. 所以时间复杂度的推导公式可以得到
$$
T(N) = T(N/2) + O(1)
$$
为了方便推导, 我们假设$N=2^M$. 我们先来复习一下替换法则, 根据上面的公式可以得到
$$
T(N/2) = T(N/4) + O(1)
$$

$$
T(N/4) = T(N/8) + O(1)
$$

我们开始推导
$$
\begin{equation*}
\begin{aligned}
T(N) &= T(\frac{N}{2}) + O(1) \\
     &= T(\frac{N}{2^2}) + 2O(1) \\
     &= T(\frac{N}{2^3}) + 3O(1) \\
     &= \cdots \\
     &= T(\frac{N}{2^M}) + MO(1) \\
     &= T(1) + MO(1) \\
     &= (M+1)O(1) \\
     &= MO(1) \\
     &= O(M) \\
     &= O(\log N)
\end{aligned}
\end{equation*}
$$
上面公式要注意的是: $T(1) = O(1)$. 为什么呢? 因为如果数组只有1个元素, 那么我们只需要$O(1)$的时间就可以确定待查找元素是否在数组中. 还要注意的一点是: $MO(1)=O(M)$. 这个很好理解.

**线性对数时间**$O(N\log N)$

我们以归并排序为例

```java
// 这里我们不给出Merge(合并)操作的具体代码,
// 只需要知道Merge的时间复杂度是O(N)就可以了.
void Merge(int[] array, int left, int mid, int right) {
    ...
}

// 归并排序的主程序, 时间复杂度设为T(N)
void MergeSort(int[] array, int left, int right) {
    if (left <= right) {                   // O(1)
        int mid = (left + right) / 2;      // O(1)
        MergeSort(array, left, mid);       // T(N/2)
        MergeSort(array, mid+1, right);    // T(N/2)
        Merge(array, left, , mid, right);  // O(N)
    }
}
```

将归并排序的主程序的每一行的时间复杂度都加起来, 可得
$$
T(N) = 2T(N/2) + O(N)
$$
我们还是假设$N=2^M$. 推导过程如下
$$
\begin{equation*}
\begin{aligned}
T(N) &= 2T(N/2) + O(N) \\
     &= 2(2T(N/4) + O(N/2)) + O(N) \\
     &= 4T(N/4) + 2O(N) \\
     &= 8T(N/8) + 3O(N) \\
     &= 2^3T(\frac{N}{2^3}) + 3O(N) \\
     &= \cdots \\
     &= 2^MT(\frac{N}{2^M}) + MO(N) \\
     &= NT(1) + \log NO(N) \\
     &= (\log N + 1)O(N) \\
     &= \log N\cdot O(N) \\
     &= O(N\log N)
\end{aligned}
\end{equation*}
$$
**指数时间**$O(2^N)$

斐波那契数列的通项公式如下
$$
Fib(N)=
\begin{cases}
0\quad &如果N=0 \\
1\quad &如果N=1 \\
Fib(N-1) + Fib(N-2)\quad &如果N\geq 2
\end{cases}
$$
转换成代码如下

```java
long Fib(int N) {
    if (N == 0 || N == 1) return N;
    else return Fib(N-1) + Fib(N-2);
}
```

而时间复杂度的分析和通项公式是一致的. 假设调用`Fib(N)`的时间复杂度是$T(N)$. 则递归调用`Fib(N-1)`的时间复杂度是$T(N-1)$, 同理`Fib(N-2)`的时间复杂度是$T(N-2)$. 于是有如下
$$
\begin{equation*}
\begin{aligned}
T(0) &= O(1) \\
T(1) &= O(1) \\
T(N) &= T(N-1) + T(N-2) + O(1)
\end{aligned}
\end{equation*}
$$
上面的式子看起来很难推导. 我们这里使用数学归纳法来解决这个问题. 首先我们假设$T(N-1)=O(2^{N-1})$. 对于$T(0)和T(1)$显然是成立的(**基准情况**). 那么递推公式就变成了
$$
\begin{aligned}
T(N) &= O(2^{N-1}) + O(2^{N-2}) + O(1) \\
     &= O(\frac{3}{4}\cdot 2^N) + O(1) \\
     &= O(2^N)
\end{aligned}
$$
这样我们就证明了$T(N)=O(2^N)$. 可以看出我们的程序的运行时间是指数时间.

### 算法的正确性

我们上面讲了如何粗糙地分析一个算法的性能. 现在我们来讲一下算法的正确性. 也就是说, 我们设计一个算法出来之后, 如何知道这个算法是否正确? 现在最常用的方式是**测试**, 也就是通过输入几个测试用例看看输出是否正确. 但这种方式只能说明对输入的测试用例, 算法的工作没有问题. 并不能说明对于所有的输入算法都能正确运行. 因为测试用例只能尽可能的覆盖输入, 而无法全部覆盖.

所以一些很关键的算法, 可能就需要使用形式化的方法来证明这个算法的正确性了. 这里我们使用的形式化方法叫做**循环不变量**(loop invariant).

#### 循环不变量

循环**不变量**是在每个循环迭代的开始和结束时为真的条件, 当我们编写一个可以正常工作的循环时, 至少隐含地依赖了一个循环不变量. 了解什么是循环不变量并明确地思考循环不变量将帮助我们编写正确, 高效的代码来实现棘手的算法.

我们以迭代实现的二分查找为例子来看一下, 为了方便讲解, 我们的**前置条件**保证要寻找的`target`一定在数组`array`中. 我们这个二分查找有以下几个前置条件:

- 数组升序排列.
- 数组中的元素都不一样.
- 寻找的目标`target`一定在数组`array`中.

```java
int IterativeBinarySearch(int[] array, int target) {
    int left = 0;
    int right = array.length - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (target > array[mid]) {
            left = mid + 1;
        } else if (target < array[mid]) {
            right = mid - 1;
        } else if (target == array[mid]) {
            assert(left <= right);
            return mid;
        }
        assert(left <= right);
    }
    return -1; // 未找到, 这里为了保证语法正确. 因为我们已经知道`target`一定在`array`中.
}
```

从概念上讲, 这个算法很简单. 但是要完全正确编写代码是很棘手的. 我们怎么知道我们得到了正确的计算`mid`? 为什么是`target < array[mid]`? 为什么`left = mid + 1`以及`right = mid -1`? 如果我们改变这些决定中的任何一个, 算法可能无法找到正确的元素.

为了说服我们自己编写的是正确的代码, 我们需要一个包含三个子句的循环不变量:

1. $array$是升序排列.
2. $left \leq right$.
3. $target \in array[left..right]$.

如果我们知道一个循环的循环不变量, 作为文档记录下来是个好主意. 我们甚至可以以加断言`assert`的方式来作为文档. 也就是在每次循环执行时执行断言.

**使用循环不变量来证明代码是正确的**

循环不变量可以帮助我们说服自己, 我们的代码, 尤其是棘手的代码, 是正确的. 它们可以帮助我们开发出正确的代码, 帮助我们编写高效的代码.

要使用循环不变量来论证代码执行我们想要的操作, 我们使用以下步骤:

1. **初始化**. 循环的第一次迭代之前, 它为真.
2. **保持**. 如果循环的某次迭代之前它为真, 那么下次迭代之前它仍为真.
3. **终止**. 在循环终止时, 循环不变量为我们提供一个有用的性质. 这个性质有助于证明算法是正确的.

让我们在二分查找算法上尝试这三个步骤.

1. **初始化**. 首先证明在第一次循环迭代之前, 循环不变量成立. 循环不变量包含三个部分:

   1. 数组升序排序, 这是我们的前置条件所保证的.
   2. 由于$array.length$至少为1, 因此$left\leq right$.
   3. $target$在$array[left..right]$中, 因为那是整个数组, 我们的前置条件保证$target$在数组里面.

   这表明在第一次循环迭代之前循环不变量成立.

2. **保持**. 由于我们代码中没有对数组做任何更改, 所以循环不变量(1)一直成立. 我们主要看循环不变量(2)和循环不变量(3)的证明. 我们先来看循环不变量(2): $left\le right$. 如果某一轮循环执行之前, 有$left\le right$成立, 我们需要证明这轮循环结束时, 也成立. 也就是第11行和第13行代码的断言成立. 由于前置条件保证了$target\in array[left..right]$, 所以一定只有以下三种情况:

   1. $target\in array[left..mid-1]$. 如果落到这个情况, 也就是第8行的条件为真, 那么本轮循环结束时, 有$left$不变, $right=mid-1$. 显然有$left<=mid-1=right$.
   2. $target\in array[mid+1..right]$. 分析同上.
   3. $target==array[mid]$. 此时直接退出循环, $left$和$right$都没变. 所以也成立.

   而且可以看到, 对于以上三种情况, 循环不变量(3)在每轮循环结束也是成立的.

3. **终止**. 我们的算法一定会终止吗? 这一点非常重要. 如果某一轮循环中有$target==array[mid]$成立, 那么我们找到了元素, 且直接`return`. 这种情况下循环就终止了. 而在没找到目标之前的每轮循环中, 要么$left=mid+1$, 要么$right=mid-1$. 也就是搜索数组的范围一直在缩小. 最坏情况下, 会一直缩小到搜索范围中只有一个元素, 也就是$left=right$的情况. 而由于我们的前置条件保证了目标一定在数组中, 所以这个元素就是目标. 而根据保持阶段的论证, 最后一轮循环结束时, 循环不变量也是成立的.

至此迭代式二分查找算法的正确性得到了证明. 我们可以放心使用了.

## 力扣之二分思想篇

### 力扣第704题: 二分查找

[题目链接](https://leetcode.cn/problems/binary-search/)

使用我们上一节的算法可以直接通过.

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (target < nums[mid]) {
                right = mid - 1;
            } else if (target > nums[mid]) {
                left = mid + 1;
            } else {
                return mid;
            }
        }

        return -1;
    }
}
```

如果我们要在数组$[1,2,3,4,5,6,7,8]$中寻找$9$这个数. 那么最终会返回$-1$. 每轮循环如下:

- 循环开始前搜索范围是:$[1,2,3,4,5,6,7,8]$
- 第一轮循环结束后搜索范围是:$[5,6,7,8]$.
- 第二轮循环结束后搜索范围是:$[7,8]$.
- 第三轮循环结束后搜索范围是:$[8]$.
- 第四轮循环结束后$left > right$. 循环退出.

也就是说在**最坏情况下**(也就是找不到目标元素), 每轮循环都砍去一半的搜索范围, 如果数组的大小$N=2^M$. 那么大概$M$轮循环之后, 就循环退出了. 所以循环执行次数是$M=\log N$次. 而每轮循环的时间复杂度是$O(1)$. 所以迭代式二分查找的时间复杂度是$O(\log N)$. 且我们需要的额外空间是几个局部变量, 所以空间复杂度是$O(1)$.

### 力扣第35题: 搜索插入位置

给定一个排序数组和一个目标值, 在数组中找到目标值, 并返回其索引. 如果目标值不存在于数组中, 返回它将会被按顺序插入的位置.

请必须使用时间复杂度为$O(\log N)$的算法.

示例 1:

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

示例 2:

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

示例 3:

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

提示:
- 1 <= nums.length <= 10<sup>4</sup>
- -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>
- nums 为 **无重复元素** 的 **升序** 排列数组
- -10<sup>4</sup> <= target <= 10<sup>4</sup>

#### 二分解法

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (target < nums[mid]) {
                right = mid - 1;
            } else if (target > nums[mid]) {
                left = mid + 1;
            } else {
                return mid;
            }
        }
        // 如果执行到这里, 那么有left == right + 1
        // 我们寻找插入位置
        if (left == nums.length) return left;
        if (right == -1) return 0;
        return left;
    }
}
```

### 力扣第74题: 搜索二维矩阵

编写一个高效的算法来判断 m x n 矩阵中, 是否存在一个目标值. 该矩阵具有如下特性:
- 每行中的整数从左到右按升序排列.
- 每行的第一个整数大于前一行的最后一个整数.

示例1:

![](74-1.jpg)

```
输入: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出: true
```

示例2:

![](74-2.jpg)

```
输入: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出: false
```

提示:
- $m == matrix.length$
- $n == matrix[i].length$
- $1 \le m, n \le 100$
- $-10^4 \le matrix[i][j], target \le 10^4$

#### 二分思路

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int i = 0;
        int j = n - 1;
        while (i < m && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            } else if (matrix[i][j] < target) {
                i++;
            } else {
                j--;
            }
        }

        return false;
    }
}
```

### 力扣第34题: 在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 nums, 和一个目标值 target. 请你找出给定目标值在数组中的开始位置和结束位置.

如果数组中不存在目标值 target, 返回 [-1, -1].

你必须设计并实现时间复杂度为 $O(\log N)$ 的算法解决此问题.

示例 1:

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```

示例 2:

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

示例 3:

```
输入: nums = [], target = 0
输出: [-1,-1]
```

提示:
- $0 \le nums.length \le 10^5$
- $-10^9 \le nums[i] \le 10^9$
- nums 是一个非递减数组
- $-10^9 \le target \le 10^9$

#### 二分解法

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int[] result = {-1, -1};
        while (left <= right) {
            int mid = (left + right) / 2;
            if (target < nums[mid]) {
                right = mid - 1;
            } else if (target > nums[mid]) {
                left = mid + 1;
            } else {
                int i = mid;
                int j = mid;

                while (i >= 0 && nums[i] == target) i--;
                while (j < nums.length && nums[j] == target) j++;

                result[0] = i + 1;
                result[1] = j - 1;
                return result;
            }
        }

        return result;
    }
}
```

### 力扣第33题: 搜索旋转排序数组

整数数组 `nums` 按升序排列, 数组中的值 **互不相同** .

在传递给函数之前, `nums` 在预先未知的某个下标 `k(0 <= k < nums.length)` 上进行了 **旋转**, 使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`(下标 从 0 开始 计数). 例如, `[0,1,2,4,5,6,7]` 在下标 3 处经旋转后可能变为 `[4,5,6,7,0,1,2]` .

给你 **旋转后** 的数组 `nums` 和一个整数 `target` , 如果 `nums` 中存在这个目标值 `target` , 则返回它的下标, 否则返回 -1 .

你必须设计一个时间复杂度为 $O(\log N)$ 的算法解决此问题.

示例 1:

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

示例 2:

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

示例 3:

```
输入: nums = [1], target = 0
输出: -1
```
 

提示:
- `1 <= nums.length <= 5000`
- <code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code>
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- <code>-10<sup>4</sup> <= target <= 10<sup>4</sup></code>

#### 二分解法

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (target == nums[mid]) {
                return mid;
            }
            if (nums[left] <= nums[mid]) {
                if (target < nums[mid] && target >= nums[left]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else if (nums[right] > nums[mid]) {
                if (target > nums[mid] && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }

        return -1;
    }
}
```

### 力扣第153题: 寻找旋转排序数组中的最小值

已知一个长度为 `n` 的数组, 预先按照升序排列, 经由 `1` 到 `n` 次 旋转 后, 得到输入数组. 例如, 原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到:

- 若旋转 4 次, 则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 7 次, 则可以得到 `[0,1,2,4,5,6,7]`

注意, 数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` .

给你一个元素值 互不相同 的数组 `nums` , 它原来是一个升序排列的数组, 并按上述情形进行了多次旋转. 请你找出并返回数组中的 **最小元素** .

你必须设计一个时间复杂度为 $O(\log N)$ 的算法解决此问题.

示例 1:

```
输入: nums = [3,4,5,1,2]
输出: 1
解释: 原数组为 [1,2,3,4,5] , 旋转 3 次得到输入数组.
```

示例 2:

```
输入: nums = [4,5,6,7,0,1,2]
输出: 0
解释: 原数组为 [0,1,2,4,5,6,7] , 旋转 4 次得到输入数组.
```

示例 3:

```
输入: nums = [11,13,15,17]
输出: 11
解释: 原数组为 [11,13,15,17] , 旋转 4 次得到输入数组.
```

提示:

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 中的所有整数 **互不相同**
- `nums` 原来是一个升序排序的数组, 并进行了 `1` 至 `n` 次旋转

#### 二分解法

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right && nums[left] > nums[right]) {
            int mid = (left + right) / 2;
            if (nums[mid] < nums[right]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return nums[left];
    }
}
```

### 力扣第4题: 寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序(从小到大)数组 `nums1` 和 `nums2`. 请你找出并返回这两个正序数组的 **中位数** .

算法的时间复杂度应该为 $O(\log (m+n))$ .

示例 1:

```
输入: nums1 = [1,3], nums2 = [2]
输出: 2.00000
解释: 合并数组 = [1,2,3] ，中位数 2
```

示例 2:

```
输入: nums1 = [1,2], nums2 = [3,4]
输出: 2.50000
解释: 合并数组 = [1,2,3,4] , 中位数 (2 + 3) / 2 = 2.5
```

提示:

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- <code>-10<sup>6</sup> <= nums1[i], nums2[i] <= 10<sup>6</sup></code>

#### 解法

这道题我们可以一下就想到, 先将两个数组合并成一个数组, 然后对合并后的数组进行排序, 然后计算中位数. 这个方法一定可行, 可惜不满足题目要求的时间复杂度. 不过我们还是给出代码.

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int[] nums = new int[nums1.length + nums2.length];

        for (int i = 0; i < nums1.length; i++) {
            nums[i] = nums1[i];
        }

        for (int j = 0; j < nums2.length; j++) {
            nums[nums1.length + j] = nums2[j];
        }

        Arrays.sort(nums);

        if (nums.length % 2 == 1) return nums[nums.length / 2];
        else return (nums[nums.length / 2] + nums[nums.length / 2 - 1]) / 2.0;
    }
}
```

> 这道题本身是《算法导论》的一道课后习题, 难度非常大. 考察的是对二分思想的掌握.

上面的暴力解法, 实际上存在的问题是没有利用习题中给出的 **先验** 信息, 也就是说习题的输入是两个 **升序排列** 的数组. 一看到"升序排列"这几个字, 就应该想到使用二分思想来解决问题.

## 力扣之哈希表篇